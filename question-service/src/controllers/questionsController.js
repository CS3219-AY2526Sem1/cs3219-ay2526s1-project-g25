// src/controllers/questionsController.js
import { supabase } from '../services/supabaseClient.js';
import { cloudinaryClient } from "../services/cloudinaryClient.js";

/**
 * Create a question (assuming admin is doing it right now).
 * Required fields validated by middleware: title, description, difficulty, topic, test_cases
 */
export async function createQuestion(req, res) {
  try {
    const { title, description, difficulty, topic, test_cases } = req.body;

    // Insert into DB. ID and created_at generated by DB default gen_random_uuid() and now().
    const payload = { title, description, difficulty, topic, test_cases };

    const { data, error } = await supabase
      .from('questions')
      .insert([payload])
      .select()
      .single();

    if (error) {
      console.error('Supabase insert error:', error);
      return res.status(500).json({ error: 'Database error', details: error.message });
    }

    return res.status(201).json(data);
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: 'Internal server error' });
  }
}

/**
 * Get a single question by id
 */
export async function getQuestionById(req, res) {
  try {
    const { id } = req.params;
    if (!id) return res.status(400).json({ error: 'Missing id parameter' });

    const { data, error } = await supabase
      .from('questions')
      .select('*')
      .eq('id', id)
      .maybeSingle();

    if (error) {
      console.error('Supabase select error:', error);
      return res.status(500).json({ error: 'Database error' });
    }
    if (!data) return res.status(404).json({ error: 'Question not found' });

    return res.json(data);
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: 'Internal server error' });
  }
}

/**
 * Get questions (list) with optional filters: ?topic=...&difficulty=...
 */
export async function listQuestions(req, res) {
  try {
    const { topic, difficulty } = req.query;
    let q = supabase.from('questions').select('*');

    if (topic) q = q.eq('topic', topic);
    if (difficulty) q = q.eq('difficulty', difficulty);

    const { data, error } = await q.order('created_at', { ascending: false });

    if (error) {
      console.error('Supabase list error:', error);
      return res.status(500).json({ error: 'Database error' });
    }

    return res.json(data);
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: 'Internal server error' });
  }
}

/**
 * Get a random question that matches filters.
 * If no matching question, return 404.
 */
export async function getRandomQuestion(req, res) {
  try {
    const { topic, difficulty } = req.query;
    let q = supabase.from('questions').select('*');

    if (topic) q = q.eq('topic', topic);
    if (difficulty) q = q.eq('difficulty', difficulty);

    const { data, error } = await q;
    if (error) {
      console.error('Supabase random select error:', error);
      return res.status(500).json({ error: 'Database error' });
    }
    if (!data || data.length === 0) {
      return res.status(404).json({ error: 'No questions found for given filters' });
    }

    const idx = Math.floor(Math.random() * data.length);
    return res.json(data[idx]);
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: 'Internal server error' });
  }
}

/**
 * Update question (admin).
 * ID must remain unchanged (DB primary key).
 */
export async function updateQuestion(req, res) {
  try {
    const { id } = req.params;
    const updates = {};
    const allowed = ['title','description','difficulty','topic','test_cases'];
    allowed.forEach(k => {
      if (req.body[k] !== undefined) updates[k] = req.body[k];
    });

    if (Object.keys(updates).length === 0) {
      return res.status(400).json({ error: 'No updatable fields provided' });
    }

    // Ensure ID not present in updates (client shouldn't change it)
    if (req.body.id && req.body.id !== id) {
      return res.status(400).json({ error: 'Cannot change question id' });
    }

    const { data, error } = await supabase
    .from('questions')
    .update(updates)  // removed updated_at
    .eq('id', id)
    .select()
    .single();

    if (error) {
      console.error('Supabase update error:', error);
      return res.status(500).json({ error: 'Database error', details: error.message });
    }
    if (!data) return res.status(404).json({ error: 'Question not found' });

    return res.json(data);
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: 'Internal server error' });
  }
}

/**
 * Delete question (admin). Permanently purge per F9.4.2
 */
export async function deleteQuestion(req, res) {
  try {
    const { id } = req.params;
    const { error } = await supabase.from('questions').delete().eq('id', id);
    if (error) {
      console.error('Supabase delete error:', error);
      return res.status(500).json({ error: 'Database error', details: error.message });
    }

    // successful deletion returns 204 No Content
    return res.status(204).send();
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: 'Internal server error' });
  }
}

// When user tries to upload an image for a question, provide a valid signature signed by
// our Cloudinary API Key. This will let Cloudinary authenticate the client when uploading the image.
export async function getImageSignature(req, res) {
  try {
    const timestamp = (new Date()).getTime();
    const paramsToSign = {
      timestamp
    }

    const signature = await cloudinaryClient.utils.api_sign_request(paramsToSign, process.env.CLOUDINARY_API_SECRET);

    res.json({
      timestamp,
      signature,
      cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
      api_key: process.env.CLOUDINARY_API_KEY
    });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: 'Internal server error' })
  }
}
